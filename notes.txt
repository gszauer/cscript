-- EP 1
In the first video i'm probably going to be explaining high level concepts and maybe make the not so good parsers.
By the end of that video, the user should be able to parse and eval something like "2 + 4 * (9 - 3)"
The second video is going to pick right up and try to to go from there

-- EP 2
The goal of the first video is going to be to be able to properly parse and execute

// Let's implement simple line comments too
int result = 2 + 4 * (9 - 3);
int default;
print(result);
print(default);

notes:
Internally, the compiler will gather a massive list of tokens. Whenever a new file is added, it's tokens are added to this list.
When compiling, this list will be fed to a parser, which will output an AST. This AST can be linked with previously serialized AST's.
The first pass AST is context free. It doesn't know types, it doesn't know if it's correct, it only knows that it's valid.

reflections:
I like the way the compiler is being built. 

-- EP 3
The goal of the second video is to start adding types. 

// These should work
int iVal = 2 + 4 * (9 - 3);
int iDefault;

float fVal = 3.14;
float fDefault;

char cVal = 't';
char cDefault;

bool bVal = true;
bool bDefault;

print(iVal); print ('\n');
print(fVal); print ('\n');
print(cVal); print ('\n');
print(bVal); print ('\n');

// these should work
iDefault = iVal;
iVal = 4;

fDefault = fVal;
fVal = 5.6;

cDefault = cVal;
cVal = 'G';

bDefault = bVal;
bVal = false;

print(iVal); print ('\n');
print(fVal); print ('\n');
print(cVal); print ('\n');
print(bVal); print ('\n');

// These should fail
//iVal = fVal; // Bad type
//iVal = cVal; // Bad type
//iVal = bVal; // Bad type
//fVal = false; // Bad type
//bVal = 'e'; // Bad type
//Val = 5.6; // Undeclared

//int fInt = 3.4;
//bool fBool = 'c';
//char fChar = 2;
//float fFloat = false;

We're also going to make the type checker functional. For example, this is valid:

char a = 'a';
b = a;

But this isn't:

char c = 7;

And neither is this

int a = 8;
char c = a;

There is no concept of null, structs or strings yet

-- EP 4
Functions

We're going to make functions work. They do not need to be dynamic just yet. Making functions work also implies making global
variables work. We will need support for shadowing. Also, variables and functions needing to be pre-installed into the environment
comes from this step. Since the type checker is esponsible for this, we will need to install the functions right after installing the 
built in (and later custom) types and install the variables only after. Global variables can have constant initializers. Functions can
No longer be called at the top level, the runtime will need to call that run function.

The goal is going to be to run this:

bool a = false;
int b;

//void g; // SHOULD BREAK
//int g = void; // SHOULD BREAK

void run() {
	print ('a'); print(':'); print(' '); print (a); print ('\n');
	int a = 8;
	print ('a'); print(':'); print(' '); print (a); print ('\n');
	{
		float a = 3.14;
		print ('a'); print(':'); print(' '); print (a); print ('\n');
		char x;
	}
	//print(x); // Should be an error

	PrintHello();
	print ('a'); print(c); print(s); print (a); print ('\n');
	char c;
}

char c = ':';
char s = ' ';

void PrintHello() {
	char a = 'b';
	print ('a'); print(':'); print(' '); print (a); print ('\n');

	int result = AddNums(7, 8);
	
	print('h');
	print('e');
	print('l');
	print('l');
	print('o');
	print(' ');
	print(result);
	print('\n');
}

int AddNums(int a, int b) {
	return a + b;
}

After Part 4 is done, i should write a LOT of tests.

I forgot, but return statements should be implemented here too. Done in part 5, added to test here

-- EP 5
Test Framework. Now that functions are working, it makes sense to start creating automated tests.
Automated tests will be divided into 3 categories: success, fail_compile, fail_runtime

-- EP 6
Objects and structs and strings. In addition to implementing structs, and type erasure trough the object type
this section will also introduce the "type" to the language, as well as is, as
type is both a data type and a callable. The callable version of type is what returns the runtime
type of an object.

Type is going to be implemented as a hybrid. Much like there is a print expression, i want to create
A type expression. That comes from "type" "(" expression ")" being found anywhere an expression is valid
This is the only way to get a valid type back. This is where the hybrid comes in. type is now a built-in 
type just like int. and type() is the only way to create a literal of it. Oh boy....

I'm probably going to break this one up into 3 seperate episodes
* Part 1, get the type keyword working
* Part 2, get structs working
* Part 3, get objects, null, is and as working

First we try to parse just the type info with:

type seven;

type intType = type(int);
type intType2 = type(3);
type intType3 = type(3 + 5);

void run() {
	type intType = type(int); // Can enter data types in there
	print(intType); print('\n');
	
	intType = type(45); // Or literals
	print(intType); print('\n');
	int val = 4;
	intType = type(val); // Can deduce the type of the expression.
	print(intType); print('\n');
	
	type t = type(type);
	print(t); print('\n');

	char x;
	bool y;
	type(x);
	type(y);
	seven = type(x);
	seven = type(y);
	print(type(run)); print('\n');
	print(seven); print('\n'); print('\n');
}

Then objects. Implementing objects is a multi-step job and take a lot of care / work
Step 1: Implement the struct primitive. This includes the keyword, parsing and type checking it.
Step 2: Implement get expressions for structs
Step 3: Implement set expressions for structs
Step 4: Make sure the struct is callable to make new ones
Step 5: Make sure struct works with type system

The goal of implementing structs is to run this code:

struct Vec3 {
	float x;
	float y = 0.0;
	float z; // = char, should break in a lot of ways
}

Vec3 forward;

void run() {
	Vec3 a = Vec3();
	a.x = 5.0;
	a.x = 6.0;
	a.x = 7.0;

	print ('x'); print(':'); print (' '); print(a.x); print ('\n');
	print(forward);print('\n'); // Forward is null
	print(type(forward));print('\n'); // Type is object
	forward = a;
	print(type(forward));print('\n'); // Type is Vec3
	print(type(Vec3));print('\n');
	print(a);print('\n');
}

Vec3 AddVectors(Vec3 a, Vec3 b) {
	Vec3 result = Vec3();

	result.x = a.x + b.x;
	result.y = a.y + b.y;
	result.z = a.z + b.z;

	return result;
}

Next, make null and object work. Interestingly enough, adding support for type erasure ran me into a problem.
For example: object o = Vec3(); Then: type(o); would always return <object> not <Vec3>, since the type of o
is object, but the value of o is Vec3. Because of this, we have to fake one of our future features, dynamic functions.
The idea is that type(dynamic o); will resolve the type of o dynamically. So it will return Vec3. This also means
that a value of null will be object. So Vec3 v = null; then type(v); would be <objecT>, not <Vec3>, since the type
of null is object

struct Vec3 {
	float x = 20.0;
	float y = 0.0;
	float z = 7.0;
}

Vec3 forward;
Vec3 up = null; // Should work

object def1 = null;
object def2;

void run() {
	object g = AddVectors(Vec3(), Vec3()); // Any struct instance can be an object
	g = Vec3(); // Can assign
	object h; // Will be null by default
	object i = null; // Can initialize to null;
	h = i;
	object k = h;

	Vec3 a = Vec3();
	a.x = 5.0;
	a.x = 6.0;
	a.x = 7.0;

	g = a;
	a.x = 1.0;
	a.y = 0.0;
	a.z = 0.0;
	a = null;

	p(g);p('\n');					// <struct vec3 1, 0, 0
	print(type(g));p('\n');			// <type object
	print(type(dynamic g));p('\n');	// <type Vec3
	p(type(g));p('\n');				// <type object
	p(type(dynamic g));p('\n');		// <type Vec3
	p(h);p('\n');					// null
	p(a);p('\n');					// null
	print(type(a));p('\n');			// <type Vec3
	p(type(dynamic a));				// <type object

	Vec3 _v2;
	Vec3 _v3 = null;
}

void p(object o) {
	print(o);
}

Vec3 AddVectors(Vec3 a, Vec3 b) {
	Vec3 result = Vec3();

	result.x = a.x + b.x;
	result.y = a.y + b.y;
	result.z = a.z + b.z;

	return result;
}

NOW Make sure type erasure works and things can be set to null. We want to also make sure that 'as' and 'is' work. 

-- EP 7 
Strings & Arrays

-- EP 9
Enumerations

-- EP 10
Multi Methods and dynamic functions

-- EP 11
Delegates 

-- EP 12
Operators

-- EP 13
Control Flow, missing operators

-- EP 14
Emit Javascript. Also, how does someone do a javascript source map?

-- EP 15
Compiler options / javascript integrtion. Need to add support for external declarations that the runtime can later hook up.
Also, add the option to pre-compile code for easy distribution. This is static linking only
Maybe also consider beefing up the runtime. Like add arguments to the "Run" function of the interpreter?

-- EP 16
Making a self hosted compiler, and running it online.

-- EP 17
Kind of a stretch, but VS Code Integration?

-- HIGH IDEAS runfor
It's for running a long function that MUST render while displaying a loading screen.
Might need a way to add a last minute saivor function. But that would require
Running to the end of frame pointless, since the 

Example:
void UpdateNavMesh() { // runfor will only work with functions that return nothing and have no dynamic arguments
	// Internally, the functions return type will be replaced with an int. A new function will be made, with a new generated name.
	// That generated name is only ever called at a runfor site
	// I don't know if nested runfor loops should be supported or not. 
	// I think it should be a runtime exception tough, as the inner one could mess up the outer ones timing.
}

runfor 16 UpdateNavMesh(); // This would yield control of execution after 16 milliseconds
runfor UpdateNavMesh(); // This would un tuntil the end of frame (since there is no time)

Yielding is easy as fuck in the dynamic interpreter, since we can just resume execution
at the next expression without worrying about state changes

I'd also consider adding a ms type, for millisecond. It's a non-nullable type.
The default value for it is '0 as ms'. We should be able to cast both integers and floats
to milliseconds with the 'as' keyword. And 'is' should work too. 
ms is also callable, calling it would return the current time in milliseconds (since app startup).
Internally, runfor takes a ms as it's argument, but both int and float are accepted and auto cast


:: Second script notes
Compiler steps
* Start out with a string of characters
	* Plain text
* Scan them into a list of tokens
	* The pre-processor should run at this state
* Parse the tokens into a tree
	* This tree does not know about types AT ALL!
	* The tree does not care what's in it, it only cares that it's a valid structure
* Collect types
	* Collect info about top level declarations only
	* Should know the details of all 
		* Structures
		* Functions
		* Enums
		* Delegates
		* Operators
* Do type checking
	* Remove enumerations from AST
	* Make sure that every expression has a type.
	* Make sure that all types are valid, everywhere
	* As far as call expressions go, the type checker only cares if it's callable at this point.
* Resolve functions
	* Make sure a void function does not return anything
	* Make sure a non void function does return something
	* Type check a calls return and what it's being assigned to
	* Convert Call expression to:
		* Static call expression
		* Dynamic call expression
		* Delegate call expression
		* Operator call expression
		* DefaultConstructor call expression

I'm not sure how to handle arrays

Generated
	* Since $ isn't a valid start to a variable name, any generated types in the type table start with $
	* Make null into a special token?? Is it not already? it can stay an object type
	* Keep in mind that 

Variables
	* Basic types are: int, float, bool, char, string, object
	* Defaults for each : 0, 0.0, false, '\0', null, null
	* Global variables can only have literal initializers, IE:
		* float PI = 3.14; is ok, but
		* float PI = _SOME_OTHER_VARIABLE; is not
	* Variables inside a function can be initialized to any expression
	* Variables can be shadowed

Enumerations
	TODO

Structs
	* Can only be declared at the global scope
	* Is just a collection of variables
	* Passed around by reference

Arrays
	* Attach brackets to the data type when declaring an array
	* Arrys are objects
	* The default value of any array is null

Control Flow
	* if/else
	* while
	* for

Functions
	* Can only be declared at the global scope
	* Can be overloaded
		* An overloaded function is a multi-function
	* By default function calls are static
		* If multiple exact matches are found, the function is ambigous
		* If no exact match is found, the candidate with the fewest number of implicit to object casts is chosen
			* If there are multiple candidates with the lowest number, the function is ambigous
	* If a function argument is an object it can become dynamic, this means the function will be resolved at runtime, not compile time
		* Runtime function selection should work the same way that compile time function selection works

Delegates
	* similar syntax to C#:
		* delegate num BinaryOperator(num x, num y);
	* Every generated function should be registered globally, with a unique generated name
		* The delegate call refers to this name

Operators
	TODO: new operator for custom constructor

Pre-processor:
	* C / C++ / C# like
	* basically an integer calculator

Type interface
	* built in primitive types: int, float, bool, char
	* a struct is a usertype
	* an object can be anything, like in c#
	* the as operator will attempt to cast an object back to what it really was
		* Will return a default value (0, 0.0, false, '\0', null) on fail
	* the is operator will return true / false checking an objects
	* There should be a built in 'type', and a typeof operator
	* null has a type of object
	* there is no inheritance, object is simply for type erasure