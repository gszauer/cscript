-- EP 1
In the first video i'm probably going to be explaining high level concepts and maybe make the not so good parsers.
By the end of that video, the user should be able to parse and eval something like "2 + 4 * (9 - 3)"
The second video is going to pick right up and try to to go from there

-- EP 2
The goal of the first video is going to be to be able to properly parse and execute

// Let's implement simple line comments too
int result = 2 + 4 * (9 - 3);
int default;
print(result);
print(default);

notes:
Internally, the compiler will gather a massive list of tokens. Whenever a new file is added, it's tokens are added to this list.
When compiling, this list will be fed to a parser, which will output an AST. This AST can be linked with previously serialized AST's.
The first pass AST is context free. It doesn't know types, it doesn't know if it's correct, it only knows that it's valid.

reflections:
I like the way the compiler is being built. 

-- EP 3
The goal of the second video is to start adding types. 

// These should work
int iVal = 2 + 4 * (9 - 3);
int iDefault;

float fVal = 3.14;
float fDefault;

char cVal = 't';
char cDefault;

bool bVal = true;
bool bDefault;

print(iVal); print ('\n');
print(fVal); print ('\n');
print(cVal); print ('\n');
print(bVal); print ('\n');

// these should work
iDefault = iVal;
iVal = 4;

fDefault = fVal;
fVal = 5.6;

cDefault = cVal;
cVal = 'G';

bDefault = bVal;
bVal = false;

print(iVal); print ('\n');
print(fVal); print ('\n');
print(cVal); print ('\n');
print(bVal); print ('\n');

// These should fail
//iVal = fVal; // Bad type
//iVal = cVal; // Bad type
//iVal = bVal; // Bad type
//fVal = false; // Bad type
//bVal = 'e'; // Bad type
//Val = 5.6; // Undeclared

//int fInt = 3.4;
//bool fBool = 'c';
//char fChar = 2;
//float fFloat = false;

We're also going to make the type checker functional. For example, this is valid:

char a = 'a';
b = a;

But this isn't:

char c = 7;

And neither is this

int a = 8;
char c = a;

There is no concept of null, structs or strings yet

-- EP 4
Functions

We're going to make functions work. They do not need to be dynamic just yet. Making functions work also implies making global
variables work. We will need support for shadowing. Also, variables and functions needing to be pre-installed into the environment
comes from this step. Since the type checker is esponsible for this, we will need to install the functions right after installing the 
built in (and later custom) types and install the variables only after. Global variables can have constant initializers. Functions can
No longer be called at the top level, the runtime will need to call that run function.

The goal is going to be to run this:

bool a = false;
int b;

//void g; // SHOULD BREAK
//int g = void; // SHOULD BREAK

void run() {
	print ('a'); print(':'); print(' '); print (a); print ('\n');
	int a = 8;
	print ('a'); print(':'); print(' '); print (a); print ('\n');
	{
		float a = 3.14;
		print ('a'); print(':'); print(' '); print (a); print ('\n');
		char x;
	}
	//print(x); // Should be an error

	PrintHello();
	print ('a'); print(c); print(s); print (a); print ('\n');
	char c;
}

char c = ':';
char s = ' ';

void PrintHello() {
	char a = 'b';
	print ('a'); print(':'); print(' '); print (a); print ('\n');
	
	print('h');
	print('e');
	print('l');
	print('l');
	print('o');
	print('\n');
}

After Part 4 is done, i should write a LOT of tests.

-- EP 5
Test Framework. Now that functions are working, it makes sense to start creating automated tests.
Automated tests will be divided into 3 categories: success, fail_compile, fail_runtime

-- EP 5
Objects and structs. In addition to implementing structs, and type erasure trough the object type
this section will also introduce the "type" to the language, as well as is, as
type is both a data type and a callable. The callable version of type is what returns the runtime
type of an object.

-- EP 6
Arrays

-- EP 7
Enumerations

-- EP 8
Multi Methods and dynamic functions

-- EP 9
Delegates 

-- EP 10
Operators

-- EP 11
Control Flow

-- EP 12
Emit Javascript. Also, how does someone do a javascript source map?

-- EP 13
Compiler options. Need to add support for external declarations that the runtime can later hook up.
Also, add the option to pre-compile code for easy distribution. This is static linking only
Maybe also consider beefing up the runtime. Like add arguments to the "Run" function of the interpreter?

-- EP 13
Making a self hosted compiler, and running it online.

-- EP 14
Kind of a stretch, but VS Code Integration?

-- HIGH IDEAS runfor
It's for running a long function that MUST render while displaying a loading screen.
Might need a way to add a last minute saivor function. But that would require
Running to the end of frame pointless, since the 

Example:
void UpdateNavMesh() { // runfor will only work with functions that return nothing and have no dynamic arguments
	// Internally, the functions return type will be replaced with an int. A new function will be made, with a new generated name.
	// That generated name is only ever called at a runfor site
	// I don't know if nested runfor loops should be supported or not. 
	// I think it should be a runtime exception tough, as the inner one could mess up the outer ones timing.
}

runfor 16 UpdateNavMesh(); // This would yield control of execution after 16 milliseconds
runfor UpdateNavMesh(); // This would un tuntil the end of frame (since there is no time)

Yielding is easy as fuck in the dynamic interpreter, since we can just resume execution
at the next expression without worrying about state changes

I'd also consider adding a ms type, for millisecond. It's a non-nullable type.
The default value for it is '0 as ms'. We should be able to cast both integers and floats
to milliseconds with the 'as' keyword. And 'is' should work too. 
ms is also callable, calling it would return the current time in milliseconds (since app startup).
Internally, runfor takes a ms as it's argument, but both int and float are accepted and auto cast


:: Second script notes
Compiler steps
* Start out with a string of characters
	* Plain text
* Scan them into a list of tokens
	* The pre-processor should run at this state
* Parse the tokens into a tree
	* This tree does not know about types AT ALL!
	* The tree does not care what's in it, it only cares that it's a valid structure
* Collect types
	* Collect info about top level declarations only
	* Should know the details of all 
		* Structures
		* Functions
		* Enums
		* Delegates
		* Operators
* Do type checking
	* Remove enumerations from AST
	* Make sure that every expression has a type.
	* Make sure that all types are valid, everywhere
	* As far as call expressions go, the type checker only cares if it's callable at this point.
* Resolve functions
	* Make sure a void function does not return anything
	* Make sure a non void function does return something
	* Type check a calls return and what it's being assigned to
	* Convert Call expression to:
		* Static call expression
		* Dynamic call expression
		* Delegate call expression
		* Operator call expression
		* DefaultConstructor call expression

I'm not sure how to handle arrays

Generated
	* Since $ isn't a valid start to a variable name, any generated types in the type table start with $
	* Make null into a special token?? Is it not already? it can stay an object type
	* Keep in mind that 

Variables
	* Basic types are: int, float, bool, char, string, object
	* Defaults for each : 0, 0.0, false, '\0', null, null
	* Global variables can only have literal initializers, IE:
		* float PI = 3.14; is ok, but
		* float PI = _SOME_OTHER_VARIABLE; is not
	* Variables inside a function can be initialized to any expression
	* Variables can be shadowed

Enumerations
	TODO

Structs
	* Can only be declared at the global scope
	* Is just a collection of variables
	* Passed around by reference

Arrays
	* Attach brackets to the data type when declaring an array
	* Arrys are objects
	* The default value of any array is null

Control Flow
	* if/else
	* while
	* for

Functions
	* Can only be declared at the global scope
	* Can be overloaded
		* An overloaded function is a multi-function
	* By default function calls are static
		* If multiple exact matches are found, the function is ambigous
		* If no exact match is found, the candidate with the fewest number of implicit to object casts is chosen
			* If there are multiple candidates with the lowest number, the function is ambigous
	* If a function argument is an object it can become dynamic, this means the function will be resolved at runtime, not compile time
		* Runtime function selection should work the same way that compile time function selection works

Delegates
	* similar syntax to C#:
		* delegate num BinaryOperator(num x, num y);
	* Every generated function should be registered globally, with a unique generated name
		* The delegate call refers to this name

Operators
	TODO: new operator for custom constructor

Pre-processor:
	* C / C++ / C# like
	* basically an integer calculator

Type interface
	* built in primitive types: int, float, bool, char
	* a struct is a usertype
	* an object can be anything, like in c#
	* the as operator will attempt to cast an object back to what it really was
		* Will return a default value (0, 0.0, false, '\0', null) on fail
	* the is operator will return true / false checking an objects
	* There should be a built in 'type', and a typeof operator
	* null has a type of object
	* there is no inheritance, object is simply for type erasure